{"date": "2025-11-27 16:27", "hash": "fe585eb4df8c88d844eeb463ea4d0302", "eval": {"HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\n\n  def parse_nested_parens(paren_string: str) -> List[int]:\n      groups = paren_string.split()\n      result = []\n      for group in groups:\n          depth = 0\n          max_depth = 0\n          for char in group:\n              if char == '(':\n                  depth += 1\n                  max_depth = max(max_depth, depth)\n              elif char == ')':\n                  depth -= 1\n          result.append(max_depth)\n      return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\n\n  def mean_absolute_deviation(numbers: List[float]) -> float:\n      if not numbers:\n          raise ValueError(\"Empty input list\")\n      mean = sum(numbers) / len(numbers)\n      total_deviation = sum(abs(x - mean) for x in numbers)\n      return total_deviation / len(numbers)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\n\n  def string_xor(a: str, b: str) -> str:\n      # Pad the shorter string with leading zeros to match the length of the longer string\n      max_len = max(len(a), len(b))\n      a = a.zfill(max_len)\n      b = b.zfill(max_len)\n\n      # Perform XOR on each bit\n      result = []\n      for bit_a, bit_b in zip(a, b):\n          if bit_a != bit_b:\n              result.append('1')\n          else:\n              result.append('0')\n\n      return ''.join(result)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\n\n  def sum_product(numbers: List[int]) -> Tuple[int, int]:\n      if not numbers:\n          return (0, 1)\n      total_sum = 0\n      total_product = 1\n      for num in numbers:\n          total_sum += num\n          total_product *= num\n      return (total_sum, total_product)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\n\n  def separate_paren_groups(paren_string: str) -> List[str]:\n      result = []\n      depth = 0\n      start_index = 0\n      skip_spaces = True\n\n      for i, char in enumerate(paren_string):\n          if char == ' ':\n              skip_spaces = True\n              continue\n          if skip_spaces:\n              skip_spaces = False\n              if char == '(':\n                  depth = 1\n                  start_index = i\n          else:\n              if char == '(':\n                  depth += 1\n              elif char == ')':\n                  depth -= 1\n              if depth == 0:\n                  result.append(paren_string[start_index:i+1])\n      return result\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\n\n  def below_zero(operations: List[int]) -> bool:\n      balance = 0\n      for op in operations:\n          balance += op\n          if balance < 0:\n              return True\n      return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(delimiter)\n        result.append(num)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\n\n  def has_close_elements(numbers: List[float], threshold: float) -> bool:\n      if len(numbers) < 2:\n          return False\n      sorted_numbers = sorted(numbers)\n      for i in range(len(sorted_numbers) - 1):\n          if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n              return True\n      return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a: int, b: int) -> int:\n    return a if b == 0 else greatest_common_divisor(b, a % b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n      return number - int(number)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\n  def longest(strings: List[str]) -> Optional[str]:\n      if not strings:\n          return None\n\n      longest_str = strings[0]\n      max_length = len(longest_str)\n\n      for s in strings[1:]:\n          current_len = len(s)\n          if current_len > max_length:\n              longest_str = s\n              max_length = current_len\n\n      return longest_str", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [string[:i] for i in range(1, len(string)+1)] if string else []", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return \"\"\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[-i:]):\n            # Append reverse of the prefix before this suffix\n            return string + string[:-i][::-1]\n    \n    return string + string[:-1][::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "from collections import Counter\n\n  def pairs_sum_to_zero(l):\n      c = Counter(l)\n      if c.get(0, 0) >= 2:\n          return True\n      for x in l:\n          if x > 0 and -x in c:\n              return True\n      return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n      return False\n    if n == 2 or n == 3:\n      return True\n    if n % 2 == 0:\n      return False\n    max_divisor = int(n**0.5) + 1\n    for i in range(3, max_divisor, 2):\n      if n % i == 0:\n        return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "def filter_integers(values: List[Any]) -> List[int]:\n      result = []\n      for element in values:\n          if isinstance(element, int):\n              result.append(element)\n      return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\n\n  def parse_music(music_string: str) -> List[int]:\n      note_map = {'o': 4, 'o|': 2, '.|': 1}\n      notes = music_string.split()\n      beats = []\n      for note in notes:\n          if note in note_map:\n              beats.append(note_map[note])\n      return beats", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "def concatenate(strings: List[str]) -> str:\n    result = \"\"\n    for s in strings:\n        result += s\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "def sort_third(l: list):\n    # Collect elements at indices divisible by 3\n    indices = list(range(0, len(l), 3))\n    # Extract and sort these elements\n    sorted_elements = sorted([l[i] for i in indices])\n    # Reconstruct the list using sorted elements at the correct positions\n    result = []\n    sorted_index = 0\n    for i in range(len(l)):\n      if i % 3 == 0:\n        result.append(sorted_elements[sorted_index])\n        sorted_index += 1\n      else:\n        result.append(l[i])\n    return result\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List\n\n  def sort_numbers(numbers: str) -> str:\n      word_to_digit = {\n          'zero': '0',\n          'one': '1',\n          'two': '2',\n          'three': '3',\n          'four': '4',\n          'five': '5',\n          'six': '6',\n          'seven': '7',\n          'eight': '8',\n          'nine': '9'\n      }\n      digit_to_word = {v: k for k, v in word_to_digit.items()}\n      \n      if not numbers.strip():\n          return \"\"\n      \n      words = numbers.split()\n      digits = [word_to_digit[word] for word in words]\n      integers = list(map(int, digits))\n      integers.sort()\n      sorted_digits = list(map(str, integers))\n      sorted_words = [digit_to_word[d] for d in sorted_digits]\n      return ' '.join(sorted_words)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "def decode_cyclic(s: str):\n    groups = [s[3*i : min(3*i+3, len(s))] for i in range((len(s)+2)//3)]\n    groups = [group[-1] + group[1:] if len(group) == 3 else group for group in groups]\n    return ''.join(groups)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["uzfplzjfzcltmdly"]], "plus_fail_tests": [["abcdefghijk"]]}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "from typing import List\n\n  def triples_sum_to_zero(l: List[int]) -> bool:\n      if len(l) < 3:\n          return False\n\n      l.sort()\n      for i in range(len(l) - 2):\n          left, right = i + 1, len(l) - 1\n          target = -l[i]\n          while left < right:\n              current_sum = l[left] + l[right]\n              if current_sum == target:\n                  return True\n              elif current_sum < target:\n                  left += 1\n              else:\n                  right -= 1\n\n      return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n: int) -> int:\n      s = set()\n      for i in range(1, n // 11 + 1):\n          s.add(11 * i)\n      for i in range(1, n // 13 + 1):\n          s.add(13 * i)\n      count = 0\n      for num in s:\n          count += str(num).count('7')\n      return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[78]], "plus_fail_tests": [[77]]}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "def fib4(n: int) -> int:\n      if n == 0:\n          return 0\n      elif n == 1:\n          return 0\n      elif n == 2:\n          return 2\n      elif n == 3:\n          return 0\n\n      a, b, c, d = 0, 0, 2, 0  # fib4(0), fib4(1), fib4(2), fib4(3)\n      for _ in range(4, n + 1):\n          new_d = a + b + c + d\n          a, b, c, d = b, c, d, new_d\n\n      return d", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "import math\n\n  def largest_divisor(n: int) -> int:\n      if n == 1:\n          return 0  # or raise error? Problem implies n > 1 based on examples\n      for i in range(2, int(math.isqrt(n)) + 1):\n          if n % i == 0:\n              return n // i\n      return 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int) -> int:\n      return n * n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\n  from collections import Counter\n\n  def remove_duplicates(numbers: List[int]) -> List[int]:\n      if not numbers:\n          return []\n\n      # Count frequency of each number\n      freq = Counter(numbers)\n      \n      # Prepare result list and a set to track added elements\n      result = []\n      added = set()\n\n      for num in numbers:\n          if freq[num] == 1:\n              if num not in added:\n                  result.append(num)\n                  added.add(num)\n      \n      return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    remainders = []\n    while x > 0:\n        remainders.append(x % base)\n        x = x // base\n    remainders.reverse()\n    return ''.join(map(str, remainders))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\n\n  def factorize(n: int) -> List[int]:\n      factors = []\n      i = 2\n      while n > 1:\n          while n % i == 0:\n              factors.append(i)\n              n //= i\n          i += 1\n      return factors\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "import math\n\n  def poly(xs: list, x: float):\n      return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n  def find_zero(xs: list) -> float:\n      a, b = -100, 100\n      for _ in range(100):\n          c = (a + b) / 2\n          if poly(xs, a) * poly(xs, c) < 0:\n              b = c\n          else:\n              a = c\n      return round((a + b) / 2, 2)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * a * h", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "def get_positive(l: list):\n    return [x for x in l if x > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n      m = len(substring)\n      n = len(string)\n      if m == 0 or n < m:\n          return 0\n      count = 0\n      for i in range(n - m + 1):\n          if string[i:i+m] == substring:\n              count += 1\n      return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "def sort_even(l: list):\n      evens = []\n      odds = []\n      for idx, val in enumerate(l):\n          if idx % 2 == 0:\n              evens.append(val)\n          else:\n              odds.append(val)\n      evens_sorted = sorted(evens)\n      result = []\n      i = j = 0\n      for idx in range(len(l)):\n          if idx % 2 == 0:\n              result.append(evens_sorted[i])\n              i += 1\n          else:\n              result.append(odds[j])\n              j += 1\n      return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Args:\n        numbers (List[float]): A list of at least two floating-point numbers.\n    \n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    # Sort the list to enable adjacent comparison\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the minimum difference and corresponding pair\n    min_diff = float('inf')\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through adjacent pairs in the sorted list\n    for i in range(1, len(sorted_numbers)):\n        current_diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            min_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return min_pair", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n      \"\"\" Return length of given string\n      >>> strlen('')\n      0\n      >>> strlen('abc')\n      3\n      \"\"\"\n      return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "def flip_case(string: str) -> str:\n      return ''.join([char.upper() if char.islower() else char.lower() for char in string])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "def fruit_distribution(s, n):\n      # Extract number of apples\n      apples = int(s.split(\" apples and \")[0])\n      # Extract number of oranges\n      oranges = int(s.split(\" oranges\")[1])\n      # Calculate mangoes\n      mangoes = n - apples - oranges\n      # Return appropriate value based on validity\n      if mangoes >= 0:\n          return mangoes\n      else:\n          return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["5 apples and 6 oranges", 19]], "plus_fail_tests": [["10 apples and 20 oranges", 50]]}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "import math\n\n  def triangle_area(a, b, c):\n      # Check if the sides form a valid triangle\n      if a + b > c and a + c > b and b + c > a:\n          # Compute semi-perimeter\n          s = (a + b + c) / 2\n          # Apply Heron's formula\n          area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n          # Round to 2 decimal places\n          return round(area, 2)\n      else:\n          return -1\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n      vowels = {'a', 'e', 'i', 'o', 'u'}\n      count = 0\n      for char in s:\n          if char in vowels:\n              count += 1\n      if len(s) > 0 and s[-1] == 'y':\n          count += 1\n      return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Alone"]], "plus_fail_tests": [["JBXFOFH"]]}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "def max_element(l: list):\n    max_val = None\n    for x in l:\n        if max_val is None or x > max_val:\n            max_val = x\n    return max_val if max_val is not None else None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "def below_threshold(l: list, t: int) -> bool:\n      all_below = True\n      for num in l:\n          if num >= t:\n              all_below = False\n              break\n      return all_below", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "def unique(l: list) -> list:\n      return sorted(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "def is_simple_power(x, n):\n      if x == 1:\n          return True\n      if n == 0:\n          return x == 0\n      if n == 1 or n == -1:\n          return x == 1\n      power = 1\n      while power < x:\n          power *= n\n          if power == x:\n              return True\n      return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-2, -2]]}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "def iscube(a):\n    if a == 0:\n        return True\n    n_candidate = round(abs(a) ** (1/3))\n    if a >= 0:\n        return n_candidate ** 3 == a\n    else:\n        return (-n_candidate) ** 3 == a", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(a):\n      def sieve(n):\n          is_prime = [True] * (n+1)\n          is_prime[0] = is_prime[1] = False\n          for i in range(2, int(n**0.5)+1):\n              if is_prime[i]:\n                  for j in range(i*i, n+1, i):\n                      is_prime[j] = False\n          return [i for i, val in enumerate(is_prime) if val]\n\n      primes = sieve(97)\n      for i in range(len(primes)):\n          p = primes[i]\n          if p > a:\n              break\n          for j in range(i, len(primes)):\n              q = primes[j]\n              if p * q > a:\n                  break\n              if (a % (p * q)) != 0:\n                  continue\n              r = a // (p * q)\n              if r in primes and r >= q:\n                  return True\n      return False\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "def fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "from collections import Counter\n\n  def search(lst):\n      freq = Counter(lst)\n      for x in sorted(freq.keys(), reverse=True):\n          if freq[x] >= x:\n              return x\n      return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    s = str(x)\n    digits = list(s)\n    if shift >= len(digits):\n        return ''.join(reversed(digits))\n    effective_shift = shift % len(digits)\n    if effective_shift == 0:\n        return s\n    # Perform circular shift by slicing\n    return ''.join(digits[-effective_shift:] + digits[:-effective_shift])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[12, 2]], "plus_fail_tests": [[987654321, 9]]}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "Python\ndef smallest_change(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_prime = 2\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 2\n\n    if n > 1:\n        largest_prime = n\n\n    return largest_prime", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n      return q == q[::-1] and sum(q) <= w", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p  # Always 1 for p > 1\n\n    result = 1\n    current_power = 2 % p  # 2^1 mod p\n\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * current_power) % p\n        current_power = (current_power * current_power) % p\n        n = n // 2\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    \n    if n == 0:\n        raise ValueError(\"Cannot compute median of an empty list.\")\n    \n    if n % 2 == 1:\n        return sorted_list[n // 2]\n    else:\n        return (sorted_list[n // 2 - 1] + sorted_list[n // 2]) / 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [smallest_value, its index],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not arr:\n        return []\n\n    min_even = None\n    min_index = -1\n\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            if min_even is None or val < min_even:\n                min_even = val\n                min_index = i\n            elif val == min_even and i < min_index:\n                min_index = i\n\n    if min_even is None:\n        return []\n    else:\n        return [min_even, min_index]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "def derivative(xs: list) -> list:\n    res = []\n    for i in range(1, len(xs)):\n        res.append(i * xs[i])\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return ''.join([c for c in text if c not in vowels])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str) -> bool:\n      balance = 0\n      for char in brackets:\n          if char == '(':\n              balance += 1\n          else:\n              balance -= 1\n          if balance < 0:\n              return False\n      return balance == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescales a list of numbers such that the smallest becomes 0 and the largest becomes 1.\n    If all numbers are equal, returns a list of zeros.\n    \"\"\"\n    if not numbers:\n        return []\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n\n    return [float((x - min_val) / (max_val - min_val)) for x in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n      prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n      count = 0\n      for c in num:\n          if c in prime_digits:\n              count += 1\n      return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n      def count_chars(lst):\n          return sum(map(len, lst))\n      \n      total1 = count_chars(lst1)\n      total2 = count_chars(lst2)\n      \n      return lst1 if total1 <= total2 else lst2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n      if not lst:\n          return []\n      lst.sort()\n      left, right = 0, len(lst) - 1\n      result = []\n      for i in range(len(lst)):\n          if i % 2 == 0:\n              result.append(lst[left])\n              left += 1\n          else:\n              result.append(lst[right])\n              right -= 1\n      return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "def common(l1: list, l2: list):\n      return sorted(set(l1) & set(l2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "def monotonic(l: list) -> bool:\n    if len(l) <= 1:\n        return True\n    is_increasing = True\n    is_decreasing = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            is_increasing = False\n        if l[i] < l[i + 1]:\n            is_decreasing = False\n    return is_increasing or is_decreasing", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str) -> bool:\n      depth = 0\n      for char in brackets:\n          if char == '<':\n              depth += 1\n          elif char == '>':\n              depth -= 1\n          if depth < 0:\n              return False\n      return depth == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    total = 0\n    for c in s:\n        if 65 <= ord(c) <= 90:\n            total += ord(c)\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n      if decimal == 0:\n          return \"db0db\"\n      binary_digits = []\n      n = decimal\n      while n > 0:\n          binary_digits.append(str(n % 2))\n          n = n // 2\n      binary_str = ''.join(reversed(binary_digits))\n      return f\"db{binary_str}db\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n      if len(s) < 3:\n          return False\n      for i in range(len(s) - 2):\n          if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n              return False\n      return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "import re\n\n  def anti_shuffle(s):\n      tokens = re.findall(r'\\S+|\\s+', s)\n      processed = []\n      for token in tokens:\n          if token.strip():  # it's a word (non-space token)\n              sorted_chars = sorted(token)\n              processed.append(''.join(sorted_chars))\n          else:  # it's a space sequence\n              processed.append(' ')\n      return ''.join(processed)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n      letter_grades = []\n      for gpa in grades:\n          if gpa > 3.7:\n              letter_grades.append(\"A+\")\n          elif gpa > 3.3:\n              letter_grades.append(\"A-\")\n          elif gpa > 3.0:\n              letter_grades.append(\"B+\")\n          elif gpa > 2.7:\n              letter_grades.append(\"B\")\n          elif gpa > 2.3:\n              letter_grades.append(\"B-\")\n          elif gpa > 2.0:\n              letter_grades.append(\"C+\")\n          elif gpa > 1.7:\n              letter_grades.append(\"C\")\n          elif gpa > 1.3:\n              letter_grades.append(\"C-\")\n          elif gpa > 1.0:\n              letter_grades.append(\"D+\")\n          elif gpa > 0.7:\n              letter_grades.append(\"D\")\n          elif gpa > 0.0:\n              letter_grades.append(\"D-\")\n          else:\n              letter_grades.append(\"E\")\n      return letter_grades\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "Python\ndef solve(N):\n    def to_binary(n):\n        if n == 0:\n            return \"0\"\n        res = []\n        while n > 0:\n            res.append(str(n % 2))\n            n //= 2\n        return ''.join(reversed(res))\n    \n    if N == 0:\n        return \"0\"\n    \n    binary_str = to_binary(N)\n    digit_sum = sum(int(bit) for bit in binary_str)\n    \n    return to_binary(digit_sum)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    return ''.join([chr((ord(c) - ord('a') + 4) % 26 + ord('a')) for c in s])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["test123"]]}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n      for j, val in enumerate(row):\n        if val == x:\n          result.append((i, j))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "def prime_length(string):\n    length = len(string)\n    if length <= 1:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n      boredoms = 0\n      start = 0\n      end_punctuation = {'.', '?', '!'}\n\n      for i, char in enumerate(S):\n          if char in end_punctuation:\n              sentence = S[start:i+1]\n              words = sentence.split()\n              if words and words[0] == 'I':\n                  boredoms += 1\n              start = i + 1\n\n      return boredoms", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["I am very happy today. I love s"]]}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "def encode(message):\n    def shift_char(c):\n        lower_c = c.lower()\n        if lower_c in {'a', 'e', 'i', 'o', 'u'}:\n            # Shift vowel by +2\n            shifted = chr((ord(lower_c) - ord('a') + 2) % 26 + ord('a'))\n            # Preserve original case\n            return shifted.upper() if c.isupper() else shifted\n        else:\n            # Non-vowel: just swap case\n            return c.swapcase()\n\n    return ''.join([shift_char(c) for c in message])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["TEST"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "def check_dict_case(d):\n    if not d:\n        return False\n    categories = []\n    for key in d:\n        if isinstance(key, str):\n            if key.islower():\n                categories.append('lower')\n            elif key.isupper():\n                categories.append('upper')\n            else:\n                categories.append('other')\n        else:\n            return False\n    return len(set(categories)) <= 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Name": "John", "Age": "36", "City": "Houston"}]], "plus_fail_tests": [[{"1": "apple", "2": "banana", "3": "cherry"}]]}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list, or None if not applicable.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(lst)\n    if sorted_lst[0] == sorted_lst[1]:\n        return None\n    return sorted_lst[1]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 2, 2, 2, 2, 2, 3, 3, 3, 3]]]}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "def add(lst):\n      return sum(value for index, value in enumerate(lst) if index % 2 == 1 and value % 2 == 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return (x == y + z) or (y == x + z) or (z == x + y)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    unit_digit_a = (a % 10 + 10) % 10\n    unit_digit_b = (b % 10 + 10) % 10\n    return unit_digit_a * unit_digit_b", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-6, -9]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "def skjkasdkd(lst):\n      def is_prime(n):\n          if n <= 1:\n              return False\n          if n == 2:\n              return True\n          if n % 2 == 0:\n              return False\n          for i in range(3, int(n**0.5) + 1, 2):\n              if n % i == 0:\n                  return False\n          return True\n\n      primes = [x for x in lst if is_prime(x)]\n\n      if not primes:\n          return 0\n\n      largest_prime = max(primes)\n      return sum(int(digit) for digit in str(largest_prime))\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "def closest_integer(value):\n    num = float(value)\n    if num.is_integer():\n        return int(num)\n    integer_part = int(num)\n    fractional_part = num - integer_part\n    if fractional_part < 0.5:\n        return integer_part\n    elif fractional_part > 0.5:\n        return integer_part + 1\n    else:  # fractional_part == 0.5\n        if integer_part >= 0:\n            return integer_part + 1\n        else:\n            return integer_part - 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["-15.5"]], "plus_fail_tests": [["-2.8"]]}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n      def is_prime(k):\n          if k <= 1:\n              return False\n          if k == 2:\n              return True\n          if k % 2 == 0:\n              return False\n          for i in range(3, int(k**0.5) + 1, 2):\n              if k % i == 0:\n                  return False\n          return True\n\n      if n <= 1:\n          return []\n\n      primes = []\n      for i in range(2, n):\n          if is_prime(i):\n              primes.append(i)\n      return primes\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    if len(array) <= 1:\n      return array[:]\n    first = array[0]\n    last = array[-1]\n    if (first + last) % 2 == 1:\n      return sorted(array)\n    else:\n      return sorted(array, reverse=True)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n      vowels = {'A', 'E', 'I', 'O', 'U'}\n      count = 0\n      for i in range(0, len(s), 2):\n          if s[i] in vowels:\n              count += 1\n      return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    # Convert c to a set for O(1) lookups\n    chars_to_remove = set(c)\n    \n    # Filter characters in s that are not in chars_to_remove\n    filtered = ''.join([char for char in s if char not in chars_to_remove])\n    \n    # Check if filtered string is a palindrome\n    is_palindrome = filtered == filtered[::-1]\n    \n    return (filtered, is_palindrome)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    \"\"\"\n    Given a list of positive integers x, return a sorted list of all elements that contain no even digits.\n    \n    Args:\n        x (List[int]): List of positive integers.\n        \n    Returns:\n        List[int]: Sorted list of integers with only odd digits, or empty list if none.\n    \"\"\"\n    # Filter numbers that have only odd digits\n    filtered = [num for num in x if all(int(d) % 2 == 1 for d in str(num))]\n    \n    # Sort the filtered list in increasing order\n    return sorted(filtered)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        s = str(i)\n        if s == s[::-1]:  # Check if palindrome\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    if not arr:\n      return True\n    sorted_arr = sorted(arr)\n    if len(arr) == 1:\n      return True\n    for i in range(len(arr) - 1):\n      if arr[i] > arr[i + 1]:\n        break\n    else:\n      if arr[-1] <= sorted_arr[0]:\n        return True\n      else:\n        return False\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4, 5, 1, 2]]], "plus_fail_tests": [[[5, 6, 7, 8, 1, 2, 3, 4]]]}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    return \"YES\" if any(num % 2 == 0 for num in lst2) else \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4]]], "plus_fail_tests": [[[2, 4, 6], [1, 3, 5]]]}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "from collections import Counter\n\n  def histogram(test):\n      if not test.strip():\n          return {}\n      \n      letters = test.split()\n      counts = Counter(letters)\n      max_count = max(counts.values())\n      result = {letter: count for letter, count in counts.items() if count == max_count}\n      return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "def f(n):\n    if n == 0:\n        return []\n    res = [0] * n\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Compute factorial\n            fact = 1\n            for j in range(1, i + 1):\n                fact *= j\n            res[i - 1] = fact\n        else:\n            # Compute triangular sum using formula\n            res[i - 1] = i * (i + 1) // 2\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    if y < x:\n        return -1\n    if y % 2 == 0:\n        candidate = y\n    else:\n        candidate = y - 1\n    if candidate >= x:\n        return candidate\n    else:\n        return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    average = round((n + m) / 2)\n    return bin(average)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "def by_length(arr):\n    valid_digits = [x for x in arr if 1 <= x <= 9]\n    valid_digits.sort()\n    valid_digits.reverse()\n    mapping = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    result = [mapping[d] for d in valid_digits]\n    return result if result else []", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n    \"\"\"\n    sequence = []\n    current = n\n    while current != 1:\n        sequence.append(current)\n        if current % 2 == 0:\n            current //= 2\n        else:\n            current = 3 * current + 1\n    sequence.append(1)  # Ensure 1 is included in the sequence\n\n    odd_numbers = [num for num in sequence if num % 2 == 1]\n    odd_numbers.sort()\n    return odd_numbers\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    if not arr:\n      return None\n\n    magnitude_sum = 0\n    sign_product = 1\n    for num in arr:\n      magnitude_sum += abs(num)\n      if num == 0:\n        sign_product = 0\n        break  # No need to process further; product remains 0\n      elif num < 0:\n        sign_product *= -1\n\n    return magnitude_sum * sign_product\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    def count_odd_digits(s):\n      odd_digits = {'1', '3', '5', '7', '9'}\n      return sum(1 for c in s if c in odd_digits)\n\n    def replace_with_count(s, count):\n      return ''.join([str(count) for _ in s])\n\n    def format_result(s, count):\n      return f\"the number of odd elements {str(count)}n the str{str(count)}ng {str(count)} of the {str(count)}nput.\"\n\n    result = []\n    for string in lst:\n      count = count_odd_digits(string)\n      processed = replace_with_count(string, count)\n      formatted = format_result(processed, count)\n      result.append(formatted)\n    return result\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    vowels = set('aeiouAEIOU')\n    \n    def is_consonant(char):\n        return char not in vowels\n    \n    if len(word) < 3:\n        return \"\"\n    \n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and is_consonant(word[i-1]) and is_consonant(word[i+1]):\n            return word[i]\n    \n    return \"\"\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "def intersection(interval1, interval2):\n      a1, a2 = interval1\n      b1, b2 = interval2\n\n      start = max(a1, b1)\n      end = min(a2, b2)\n\n      if start > end:\n          return \"NO\"\n\n      length = end - start\n\n      def is_prime(n):\n          if n < 2:\n              return False\n          for i in range(2, int(n**0.5) + 1):\n              if n % i == 0:\n                  return False\n          return True\n\n      return \"YES\" if is_prime(length) else \"NO\"\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "Python\ndef match_parens(lst):\n    def is_valid(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_valid(s1 + s2):\n        return 'Yes'\n    if is_valid(s2 + s1):\n        return 'Yes'\n    return 'No'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n      def is_consonant(char):\n          return char.isalpha() and char.lower() not in {'a', 'e', 'i', 'o', 'u'}\n      \n      words = s.split()\n      result = []\n      \n      for word in words:\n          consonant_count = sum(1 for c in word if is_consonant(c))\n          if consonant_count == n:\n              result.append(word)\n      \n      return result\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    if ' ' in txt:\n      return txt.split()\n    elif ',' in txt:\n      return txt.split(',')\n    else:\n      return sum(1 for c in txt if c.islower() and ord(c) % 2 == 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["aaabb"]], "plus_fail_tests": [["abc123"]]}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    def get_sum(n: int) -> int:\n        s = str(n)\n        if n >= 0:\n            return sum(int(d) for d in s)\n        else:\n            first_digit = -int(s[1])\n            rest = sum(int(c) for c in s[2:]) if len(s) > 2 else 0\n            return first_digit + rest\n\n    count = 0\n    for num in arr:\n        if get_sum(num) > 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "def minPath(grid, k):\n        \"\"\"\n        Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n        each cell of the grid contains a value. Every integer in the range [1, N * N]\n        inclusive appears exactly once on the cells of the grid.\n\n        You have to find the minimum path of length k in the grid. You can start\n        from any cell, and in each step you can move to any of the neighbor cells,\n        in other words, you can go to cells which share an edge with your current\n        cell.\n        Please note that a path of length k means visiting exactly k cells (not\n        necessarily distinct).\n        You CANNOT go off the grid.\n        A path A (of length k) is considered less than a path B (of length k) if\n        after making the ordered lists of the values on the cells that A and B go\n        through (let's call them lst_A and lst_B), lst_A is lexicographically less\n        than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n        such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n        lst_A[j] = lst_B[j].\n        It is guaranteed that the answer is unique.\n        Return an ordered list of the values on the cells that the minimum path go through.\n\n        Examples:\n\n            Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n            Output: [1, 2, 1]\n\n            Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n            Output: [1]\n        \"\"\"\n        if k == 0:\n            return []\n        \n        n = len(grid)\n        # Find the position of 1\n        start_i, start_j = 0, 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    start_i, start_j = i, j\n                    break\n            else:\n                continue\n            break\n        \n        path = [1]\n        current_i, current_j = start_i, start_j\n        \n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\n        \n        for _ in range(k-1):\n            min_val = float('inf')\n            next_i, next_j = current_i, current_j\n            for di, dj in directions:\n                ni, nj = current_i + di, current_j + dj\n                if 0 <= ni < n and 0 <= nj < n:\n                    if grid[ni][nj] < min_val:\n                        min_val = grid[ni][nj]\n                        next_i, next_j = ni, nj\n            path.append(min_val)\n            current_i, current_j = next_i, next_j\n        \n        return path", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    if len(lst) == 1:\n      return True\n    for i in range(len(lst) - 1):\n      if lst[i] >= lst[i+1]:\n        return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "def words_string(s):\n      if not s:\n          return []\n      normalized = s.replace(',', ' ')\n      words = [word.strip() for word in normalized.split()]\n      return words", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1') if x >= 0 else bin(x).count('1') + 100000, x if x >= 0 else x + 100000))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    if not nums:\n        return 0\n    current_min = min_so_far = nums[0]\n    for i in range(1, len(nums)):\n        current_min = min(nums[i], current_min + nums[i])\n        min_so_far = min(min_so_far, current_min)\n    return min_so_far", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "from typing import List\n\n  def max_fill(grid: List[List[int]], capacity: int) -> int:\n      lowers = 0\n      for row in grid:\n          row_sum = sum(row)\n          if row_sum > 0:\n              lowers += (row_sum + capacity - 1) // capacity\n      return lowers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "def valid_date(date):\n    \"\"\"\n    Validates a given date string according to specified rules.\n    Returns True if the date is valid; False otherwise.\n    \"\"\"\n    parts = date.split('-')\n    \n    # Check format: mm-dd-yyyy\n    if len(parts) != 3:\n        return False\n    \n    month_str, day_str, year_str = parts\n    \n    # Check if all parts are numeric\n    try:\n        month = int(month_str)\n        day = int(day_str)\n        year = int(year_str)\n    except ValueError:\n        return False\n    \n    # Rule 3: Month must be between 1 and 12\n    if not (1 <= month <= 12):\n        return False\n    \n    # Rule 2: Day must be at least 1\n    if day < 1:\n        return False\n    \n    # Helper function to check leap year\n    def is_leap(y):\n        if y % 4 != 0:\n            return False\n        elif y % 100 != 0:\n            return True\n        else:\n            return y % 400 == 0\n    \n    # Check specific day validity per month\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        max_day = 31\n    elif month in [4, 6, 9, 11]:\n        max_day = 30\n    elif month == 2:\n        max_day = 29 if is_leap(year) else 28\n    else:\n        return False  # Should not reach here due to earlier month check\n    \n    # Rule 2: Day must not exceed max_day for the month\n    if day > max_day:\n        return False\n    \n    # If all checks passed\n    return True\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n      # Extract the first k elements\n      first_k = arr[:k]\n      \n      # Define the condition for at most two digits\n      def has_at_most_two_digits(x):\n          return -99 <= x <= 99\n      \n      # Filter and sum qualifying elements\n      result = sum(x for x in first_k if has_at_most_two_digits(x))\n      \n      return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    sum_result = 0\n    for i, val in enumerate(lst):\n        if i % 2 == 0 and val % 2 != 0:\n            sum_result += val\n    return sum_result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n      if k == 0:\n          return []\n      \n      # Create list of (value, original_index)\n      indexed_arr = [(val, idx) for idx, val in enumerate(arr)]\n      \n      # Sort by value descending, then by index ascending to preserve order of duplicates\n      sorted_arr = sorted(indexed_arr, key=lambda x: (-x[0], x[1]))\n      \n      # Take first k elements and extract their values\n      top_values = [val for val, idx in sorted_arr[:k]]\n      \n      # Sort the selected values in ascending order for the final output\n      top_values.sort()\n      \n      return top_values", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    return [n + 2 * k for k in range(n)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n      def strength(ext):\n          cap = sum(1 for c in ext if c.isupper())\n          sm = sum(1 for c in ext if c.islower())\n          return cap - sm\n\n      best_ext = None\n      best_strength = float('-inf')\n\n      for ext in extensions:\n          current_strength = strength(ext)\n          if current_strength > best_strength:\n              best_strength = current_strength\n              best_ext = ext\n\n      return f\"{class_name}.{best_ext}\"\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "from typing import List\n\n  def get_digit_sum(n: int) -> int:\n      return sum(int(digit) for digit in str(abs(n)))\n\n  def order_by_points(nums: List[int]) -> List[int]:\n      if not nums:\n          return []\n      \n      # Pair each number with its index, then sort based on digit sum and original index\n      indexed_nums = [(num, idx) for idx, num in enumerate(nums)]\n      sorted_nums = sorted(indexed_nums, key=lambda x: (get_digit_sum(x[0]), x[1]))\n      \n      # Extract the numbers in the new order\n      result = [num for num, idx in sorted_nums]\n      return result\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "def words_in_sentence(sentence):\n      def is_prime(n):\n          if n <= 1:\n              return False\n          for i in range(2, int(n**0.5) + 1):\n              if n % i == 0:\n                  return False\n          return True\n\n      words = sentence.split()\n      filtered = [word for word in words if is_prime(len(word))]\n      return ' '.join(filtered) if filtered else ''\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "Python\ndef int_to_mini_roman(number):\n    roman_numerals = [\n        (1000, 'm'),\n        (900, 'cm'),\n        (500, 'd'),\n        (400, 'cd'),\n        (100, 'c'),\n        (90, 'xc'),\n        (50, 'l'),\n        (40, 'xl'),\n        (10, 'x'),\n        (9, 'ix'),\n        (5, 'v'),\n        (4, 'iv'),\n        (1, 'i')\n    ]\n    result = ''\n    for value, symbol in roman_numerals:\n        while number >= value:\n            result += symbol\n            number -= value\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n      result = []\n      i = 0\n      n = len(text)\n      in_space = False\n      space_count = 0\n\n      while i < n:\n          if text[i] == ' ':\n              if not in_space:\n                  in_space = True\n                  space_count = 1\n              else:\n                  space_count += 1\n              i += 1\n          else:\n              if in_space:\n                  if space_count == 1:\n                      result.append('_')\n                  else:\n                      result.append('-')\n                  in_space = False\n                  space_count = 0\n              result.append(text[i])\n              i += 1\n\n      # Handle trailing spaces after loop ends\n      if in_space:\n          if space_count == 1:\n              result.append('_')\n          else:\n              result.append('-')\n\n      return ''.join(result)\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    def to_numeric(x):\n        if isinstance(x, str):\n            return float(x.replace(',', '.'))\n        return float(x)\n    \n    left_val = to_numeric(a)\n    right_val = to_numeric(b)\n    \n    if left_val > right_val:\n        return a\n    elif right_val > left_val:\n        return b\n    else:\n        return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "Python\ndef is_nested(string):\n    res = []\n    balance = 0\n    max_depth = 0\n    for c in string:\n        if c == '[':\n            res.append(c)\n            balance += 1\n            if balance > max_depth:\n                max_depth = balance\n        elif c == ']':\n            if balance > 0:\n                res.append(c)\n                balance -= 1\n    if balance == 0 and len(res) >= 2:\n        if len(res) == 2:\n            return False\n        else:\n            return max_depth >= 2\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "import math\n\n  def simplify(x, n):\n      # Split fractions into numerators and denominators\n      num_x, denom_x = map(int, x.split('/'))\n      num_n, denom_n = map(int, n.split('/'))\n\n      # Compute total numerator and denominator of the product\n      total_num = num_x * num_n\n      total_den = denom_x * denom_n\n\n      # Compute greatest common divisor of total_num and total_den\n      gcd_value = math.gcd(total_num, total_den)\n\n      # Simplify the fraction\n      simplified_den = total_den // gcd_value\n\n      # Check if the simplified denominator is 1 (i.e., result is a whole number)\n      return simplified_den == 1\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "Python\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    words = txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    last_char = txt[-1]\n    return last_char.isalpha() and len(last_word) == 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n      if len(arr) < 2:\n          return -1\n      max_index = -1\n      for i in range(1, len(arr)):\n          if arr[i] <= arr[i-1]:\n              max_index = i\n      return max_index", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "Python\ndef specialFilter(nums):\n    def get_first_digit(n):\n        n = abs(n)\n        while n >= 10:\n            n //= 10\n        return n\n\n    count = 0\n    for num in nums:\n        if num > 10:\n            first = get_first_digit(num)\n            last = num % 10\n            if first in {1, 3, 5, 7, 9} and last in {1, 3, 5, 7, 9}:\n                count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    ordered_planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in ordered_planets or planet2 not in ordered_planets:\n        return ()\n    i1 = ordered_planets.index(planet1)\n    i2 = ordered_planets.index(planet2)\n    if abs(i1 - i2) <= 1:\n        return ()\n    start = min(i1, i2) + 1\n    end = max(i1, i2)\n    return tuple(ordered_planets[start:end])\n</think>", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\"\"\"\n    return n % 2 == 0 and n >= 8", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "def digits(n):\n    product = 1\n    has_even = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n        else:\n            has_even = True\n        n = n // 10\n    return 0 if has_even else product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[54]], "plus_fail_tests": [[182135]]}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    n = len(b)\n    if n == 0:\n        return False\n    doubled_b = b + b\n    for i in range(n):\n        rotation = doubled_b[i:i+n]\n        if rotation in a:\n            return True\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", ""]]}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "\ndef get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n\n21", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[1]]}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    return sum(x**2 for x in lst if isinstance(x, int) and x >= 0 and x % 2 == 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n      \"\"\"\n      Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n      Example:\n          even_odd_count(-12) ==> (1, 1)\n          even_odd_count(123) ==> (1, 2)\n      \"\"\"\n      num = abs(num)\n      if num == 0:\n          return (1, 0)\n      s = str(num)\n      even_count = 0\n      odd_count = 0\n      for ch in s:\n          digit = int(ch)\n          if digit % 2 == 0:\n              even_count += 1\n          else:\n              odd_count += 1\n      return (even_count, odd_count)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n      eat_amount = min(need, remaining)\n      total_eaten = number + eat_amount\n      remaining_after = remaining - eat_amount\n      return [total_eaten, remaining_after]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "def sorted_list_sum(lst):\n    return sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return x if is_prime(n) else y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n    if not lst:\n        return 0\n    total_sum = 0\n    for i in range(len(lst)):\n        x = lst[i]\n        if i % 3 == 0:\n            total_sum += x ** 2\n        elif i % 4 == 0:\n            total_sum += x ** 3\n        else:\n            total_sum += x\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    max_word = \"\"\n    for word in words:\n      unique_chars = len(set(word))\n      current_unique = len(set(max_word)) if max_word else 0\n      if unique_chars > current_unique:\n        max_word = word\n      elif unique_chars == current_unique:\n        if word < max_word:\n          max_word = word\n    return max_word", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n      return [abs(game[i] - guess[i]) for i in range(len(game))]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    return (a, b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "def right_angle_triangle(a, b, c):\n    if a >= b and a >= c:\n        return a * a == b * b + c * c\n    elif b >= a and b >= c:\n        return b * b == a * a + c * c\n    else:\n        return c * c == a * a + b * b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "import math\n\ndef sum_squares(lst):\n    return sum(x**2 for x in [math.ceil(num) for num in lst])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "def do_algebra(operator, operand):\n      result = str(operand[0])\n      for i in range(len(operator)):\n          result += operator[i] + str(operand[i+1])\n      return eval(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    prefix, suffix = parts\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if sum(1 for c in file_name if c.isdigit()) > 3:\n        return 'No'\n    return 'Yes'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "def string_to_md5(text):\n      \"\"\"\n      Given a string 'text', return its MD5 hash equivalent string.\n      If 'text' is an empty string, return None.\n\n      >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n      \"\"\"\n      if not text:\n          return None\n      import hashlib\n      hash_object = hashlib.md5(text.encode('utf-8'))\n      return hash_object.hexdigest()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "def solve(s):\n    has_letter = any(char.isalpha() for char in s)\n    if not has_letter:\n        return s[::-1]\n    else:\n        return ''.join([char.swapcase() if char.isalpha() else char for char in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "def tri(n):\n    if n < 0:\n        return []\n    res = []\n    if n >= 0:\n        res.append(1)  # tri(0)\n    if n >= 1:\n        res.append(3)  # tri(1)\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            res.append(1 + i // 2)\n        else:\n            # Compute tri(i+1) first since it's even\n            res.append(1 + (i + 1) // 2)\n            # Now compute tri(i) using the recurrence\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1]\n    return res[:n + 1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "def prime_fib(n: int):\n    \"\"\"\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    \"\"\"\n    def is_prime(x):\n      if x < 2:\n        return False\n      for i in range(2, int(x**0.5)+1):\n        if x % i == 0:\n          return False\n      return True\n\n    a, b = 0, 1\n    count = 0\n    while True:\n      a, b = b, a + b\n      if is_prime(a):\n        count += 1\n        if count == n:\n          return a", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12]]}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n      start = min(a, b)\n      end = max(a, b)\n      valid_evens = {2, 4, 6, 8}\n      result = [x for x in range(start, end + 1) if x in valid_evens]\n      return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321, 123456789]]}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int) -> str:\n      if n < 0:\n          return None\n      return ' '.join(str(i) for i in range(n + 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 8 * 10 ** (n - 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "def special_factorial(n):\n    result = 1\n    current_fact = 1\n    for k in range(1, n + 1):\n        current_fact *= k\n        result *= current_fact\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}