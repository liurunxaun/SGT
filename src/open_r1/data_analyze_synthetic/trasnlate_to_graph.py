import pandas as pd
import json
from openai import OpenAI
from tqdm import tqdm
import time
import re

# ================= 配置区域 =================
# 替换为你的 DashScope API Key
API_KEY = "sk-8d445207b1ab47efb83069ccc1b845b6" 
BASE_URL = "https://dashscope.aliyuncs.com/compatible-mode/v1"
MODEL_NAME = "qwen-max"

# 输入和输出文件路径
INPUT_FILE = "/ssd5/rxliu/datasets/SFT-Data/DeepScaleR/test_qwen3-max-preview_results_correct.xlsx"
OUTPUT_FILE = "/ssd5/rxliu/datasets/SFT-Data/DeepScaleR/test_qwen3-max_translate_graph_reasoning.xlsx"

# ================= Prompt 模板 =================
# 这里放入你完整的 System Prompt
SYSTEM_PROMPT = r"""
You are a helpful AI Assistant that provides well-reasoned and detailed responses. I will provide you with a mathematical problem and a problem reasoning process generated by a LLM. I need you to write the reasoning process into a special format. Respond in the following format: <think>\n...\n</think>\n<answer>\n...\n</answer>

Besides, you must comply with below conditions:
1.During the <think> phase you should organize the chain of thought using below tags:
- known: known conditions that can be found in the question.
- generate: from the current reasoning state, generate one or more new reasoning steps. It represents a step forward in the process of reasoning.
- aggregate: merge multiple steps or jointly reason over them to produce a new reasoning step.
- reflection: go back to a previous reasoning step. Used to re-examine the correctness of a step or process.
- refine: improve the current node. It is a refined modification of a certain node's statement, without producing a substantial step forward in the reasoning process.
- associative thinking: comparing the curent reasoning graph structure with other similar graph structures, in order to facilitate the current reasoning process. For example, when solving a math problem, recalling the solution methods used in previous similar problems.
- reverse thinking: starting from the goal of the problem, considering possible solution paths, and filtering them with the given conditions. This builds a abstruct reverse reasoning path from the goal to the conditions, from the unknown to the known. At this stage, you do not need to perform specific actions to get the answer. You just need to use reverse thinking to think about the reasoning method. The specific reasoning will be performed in the following tags.
2.At each further reasoning step you must choose one of these tags and wrap that step's output with the chosen tag. For example: <generate>...</generate>
3.The complete think phase must start with <known>...</konwn>, and the final inference tag must include the final result of the question.
4.The tag content inside is a series of thinking steps, organized in a node based manner with node_id and parents. You need to ensure that the thinking process is coherent and effective, and ultimately these nodes can be organized into a directed graph. The format example for each node is as follows:
{
    node_id:The unique identifier of a node, usually an integer, increasing from 1.
    parents:A list of parent node IDs for this node, used to establish inference dependencies. If there is no parent node, you can fill in none.
    content:The content of this step
}
5.For the content wrapped in different tags, there are the following formal requirements:
- konwn:It wraps one or more nodes, and the parents of these nodes should all be "none".
- generate:It wraps one or more nodels, (1) If it wraps one node, the parents of this nodes should be a single node. (2) If it wraps two or more nodes, the parents of these nodes should be a same single node.
- aggregate: It wraps one node, and the parent of this node should be multiple nodes.
- reflection: It wraps one node, and the parent of this node should be one or more nodes. Its parent_ids must include the last node of the current reasoning chain.
- refine: It wraps one node, and the parent of this node should be the last node in the current reasoning chain.
- associative thinking: It wraps one node, and the parent of this node should be one or more nodes.
- reverse thinking:It wraps one node, and the parent of this node should be one or more nodes.
6.If a tag contains multiple nodes, the parents of these nodes cannot contain other nodes in the tag.
7.If a tag contains multiple nodes, the nodes should be separated by commas. Within a node, different tags do not require commas and should be separated by line breaks. 

Please strictly follow the above format and requirements.
Try to preserve the content of the original LLM reasoning process as much as possible to ensure the coherence of the thinking process
Below I'll give you two examples:

question 1:
Find the smallest number \( n \) such that given any \( n \) distinct numbers from \(\{1, 2, 3, \ldots, 999\}\), one can choose four different numbers \( a, b, c, d \) such that \( a + 2b + 3c = d \).

LLM reasoning process:
The set is $\{1, 2, \ldots, 999\}$. We are to find the smallest $n$ such that any subset of size $n$ contains distinct $a, b, c, d$ with $a + 2b + 3c = d$. Moreover, $a, b, c, d$ must be distinct elements from the chosen $n$ numbers.
To find the minimal $n$ that forces the equation $a + 2b + 3c = d$ to hold among any $n$-element subset, we consider the maximal size of a subset that avoids this equation; then $n$ is one more than that maximum.
Let $S \subseteq \{1,\ldots,999\}$ be a subset with no four distinct elements satisfying $a + 2b + 3c = d$. We want to maximize $|S|$.
This resembles extremal combinatorics problems like Schur's theorem or sum-free sets. In such problems, choosing large numbers often avoids linear equations because the RHS $(d)$ would exceed the universe bound.
If we choose only large numbers, say all numbers $> T$, then
\[a + 2b + 3c \ge 1*T + 2*T + 3*T = 6T,\]
so if $6T > 999$, then $d = a + 2b + 3c \notin \{1,\ldots,999\}$, hence cannot be in $S$.

response:
<think>
    <known>
        {
            node_id:1
            parents:none
            content:The set is {1, 2, ..., 999}
        },
        {
            node_id:2
            parents:none
            content:We are to find the smallest n such that any subset of size n contains distinct a,b,c,d with a + 2b + 3c = d
        },
        {
            node_id:3
            parents:none
            content:a, b, c, d must be distinct elements from the chosen n numbers
        }
    </known>

    <reverse thinking>
        {
            node_id:4
            parents:2
            content:To find the minimal n that forces the equation a + 2b + 3c = d to hold among any n-element subset, we consider the maximal size of a subset that avoids this equation; then n is one more than that maximum.
        }
    </reverse thinking>

    <generate>
        {
            node_id:5
            parents:4
            content:Let S ⊆ {1,...,999} be a subset with no four distinct elements satisfying a + 2b + 3c = d. We want to maximize |S|.
        }
    </generate>

    <associative thinking>
        {
            node_id:6
            parents:5
            content:This resembles extremal combinatorics problems like Schur's theorem or sum-free sets. In such problems, choosing large numbers often avoids linear equations because the RHS (d) would exceed the universe bound.
        }
    </associative thinking>

    <generate>
        {
            node_id:7
            parents:6
            content:If we choose only large numbers, say all numbers > T, then a + 2b + 3c ≥ 1*T + 2*T + 3*T = 6T, so if 6T > 999, then d = a + 2b + 3c ∉ {1,...,999}, hence cannot be in S.
        }
    </generate>
......
I omitted the subsequent reasoning and answer generation process. In this example, you mainly learned how to use reverse thinking and associative thinking.


question 2:
Find the sum of all integer bases b>9 for which 17_{b} is a divisor of 97_{b}

LLM reasoning process:
For the second question, we have $b > 9$. The condition is that $17_{b}$ is a divisor of $97_{b}$, and $b$ is an integer.
Since\[17_{b} = b + 7\]and\[97_{b} = 9*b + 7,\]we require\[9*b + 7 = k(b + 7),\quad k > 0,\ k\ \text{is an integer}.\]
Solving this gives\[b = (7 - 7k)/(k - 9),\quad 1 < k < 9,\ k\ \text{is an integer}.\]
When dealing with this type of problem before, I used the enumeration method, and I can apply the same method here as well.
Next, I should enumerate $k$ under the condition that $1 < k < 9$, $k$ is an integer, and calculate when $b$ satisfies the condition that $b > 9$ and $b$ is an integer.
\begin{itemize}
    \item If $k = 2$, $b = 1$, false.
    \item If $k = 3$, $b = 14/6$, false.
    \item If $k = 4$, $b = 21/5$, false.
    \item If $k = 5$, $b = 7$, false.
    \item If $k = 6$, $b = 35/3$, false.
    \item If $k = 7$, $b = 21$, true.
    \item If $k = 8$, $b = 49$, true.
\end{itemize}
But wait: Also $b+7 = ?$ and $9*b+7 = ?$ Possibly $b+7 = 56$ and $9*b+7 = 448$? $448/56 = 8$. Yes.

Therefore, the sum is\[21 + 49 = 70.\]

response:
<think>

    <known>
        {
            node_id:1
            parents:none
            content:b>9
        },
        {
            node_id:2
            parents:none
            content:17_{b} is a divisor of 97_{b}
        },
        {
            node_id:3
            parents:none
            content:b is an integer
        }
    </known>

    <generate>
        {
            node_id:4
            parents:2
            content:17_{b}=b+7
        },
        {
            node_id:5
            parents:2
            content:97_{b}=9*b+7
        },
    </generate>
    <aggregate>
        {
            node_id:6
            parents:2,4,5
            content: 9*b+7=k(b+7),k>0,k is an integer
        },
    </aggeregate>
    <generate>
        {
            node_id:7
            parents:6
            content:b=(7-7k)/(k-9),1<k<9,k is an integer
        }
    </generate>
    <associative thinking>
        {
            node_id:8
            parents:7
            content:When dealing with this type of problem before, I used the enumeration method, and I can apply the same method here as well.
        }
    </associative thinking>
    <aggregate>
        {
            node_id:9
            parents:1,3,7,8
            content:Next, I should enumerate k under the condition that 1<k<9, k is an integer, and calculate when b satisfies the condition that b>9 and b is an integer.
        },
    </aggeregate>
    <generate>
        {
            node_id:10
            parents:9
            content:1.if k=2,b=1,false.
        },
        {
            node_id:11
            parents:9
            content:2. if k=3,b=14/6,false.
        },
        {
            node_id:12
            parents:9
            content:3. if k=4,b=21/5,false.
        },
        {
            node_id:13
            parents:9
            content:4. if k=5,b=7,false.
        },
        {
            node_id:14
            parents:9
            content:5. if k=6,b=35/3,false.
        },
        {
            node_id:15
            parents:9
            content:6. if k=7,b=21,true.
        },
        {
            node_id:16
            parents:9
            content:7.if k=8,b=49,true.
        }
    </generate>
    <reflection>
        {
            node_id:17
            parents:6,16
            content:But wait: Also b+7=? and 9*b+7=? Possibly b+7=56 and 9*b+7=448? 448/56=8 Yes.
        }
    </reflection>
    <aggeregate>
        {
            node_id:18
            parents:10,11,12,13,14,15,16
            content:Sum=21+49=70
        }
    </aggeregate>

</think>

<answer>
    70
</answer>

"""

# 初始化 OpenAI 客户端 (用于调用 DashScope)
client = OpenAI(
    api_key=API_KEY,
    base_url=BASE_URL
)

def get_graph_reasoning(problem, original_reasoning):
    """
    调用 Qwen API 将原始推理转换为图结构推理
    """
    user_content = f"Question:\n{problem}\n\nLLM reasoning process:\n{original_reasoning}\n\nResponse:"
    
    try:
        completion = client.chat.completions.create(
            model=MODEL_NAME,
            messages=[
                {'role': 'system', 'content': SYSTEM_PROMPT},
                {'role': 'user', 'content': user_content}
            ],
            temperature=0.1, # 降低温度以保证格式遵循
            top_p=0.9
        )
        return completion.choices[0].message.content
    except Exception as e:
        print(f"Error: {e}")
        return None

def main():
    # 1. 读取数据
    print(f"Loading data from {INPUT_FILE}...")
    df = pd.read_excel(INPUT_FILE)
    
    # 建议先测试前几条
    # df = df.head(5) 
    
    print(f"Processing {len(df)} rows...")
    
    # 2. 准备新列
    graph_responses = []
    
    # 3. 循环处理 (使用 tqdm 显示进度)
    for index, row in tqdm(df.iterrows(), total=df.shape[0]):
        problem = row.get('problem', '')
        reasoning = row.get('qwen_reasoning', '')
        
        if pd.isna(problem) or pd.isna(reasoning):
            graph_responses.append("Error: Missing Data")
            continue
            
        # 调用 API
        response = get_graph_reasoning(problem, reasoning)
        graph_responses.append(response)
        
        # 简单的速率限制处理 (Qwen-max 限流较宽松，但建议保留)
        time.sleep(0.5) 

    # 4. 保存结果
    df['graph_structured_reasoning'] = graph_responses
    
    print(f"Saving results to {OUTPUT_FILE}...")
    df.to_excel(OUTPUT_FILE, index=False)
    print("Done!")

if __name__ == "__main__":
    main()